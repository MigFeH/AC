-- Ver contenido de un directorio: ls
-- Ver contenido de un fichero: cat nombreFichero o ruta absoluta/relativa

-- Retroceder al directorio anterior: cd -
-- Subir un nivel en la jerarquía de directorios: cd ..

-- Directorio actual: ./
-- Directorio padre: ../

-- Ruta absoluta (nos permite acceder a un directorio a través de la jerarquía de directorios, nos permite acceder independientemente del directorio en el que esté situado el usuario): /etc/hostname
-- Ruta relativa: con la misma sintaxis que en la ruta absoluta pero con el uso de los directorios especiales "." (directorio actual) y ".." (directorio padre), estas rutas nunca comienzan por el directorio raíz "/": ../../etc/hostname (siendo el directorio en el que nos encontramos: /home/student; luego, de ahí vienen los dos directorios padre "..") 

-- Directorio raíz (simbolizado con /) (contiene el directorio de trabajo HOME entre otros): cd /
-- Directorio HOME (simbolizado con ~ o $, pero en la MV aparece como ~$): cd

-- Mostrar permisos: ls -l

-- Comprobar con qué usuario se está dentro del sistema: whoami

-- Crear un directorio: mkdir rutaAbsoluta o rutaRelativa

-- Borrar ficheros: rm nombreFichero


-- DIRECTORIO = CARPETA (ESA ES UNA ANALOGÍA)


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- Compilacion (esto genera un ficheroObjeto con extensión .o): gcc -c nombreFichero.c

-- Compilacion y enlazado a la vez (esto genera directamente el ejecutable): gcc nombreFichero.c -o nombreEjecutable

-- Enlazado (esto genera un ejecutable): gcc nombreFicheroObjeto.o -o nombreEjecutable


-- Compilación CON INFORMACIÓN PARA DEPURAR: gcc -c nombreFichero.c -g




-- LIDIAR CON FICHEROS CON CABECERA --
	
	1º) En un programa .c hacemos el método que va a ser llamado y ponemos: #include "nombreFicheroCabecera.h"

	2º) Crear el fichero de cabecera "nombreFicheroCabecera.h" y poner al principio del fichero: #pragma once
	    Luego ponemos la cabecera del método del programa.c, ejemplo: double circleArea(double radius);

	3º) Editar el fichero.c con el programa principal que llamará al método externo. Uno de sus include debe ser: #include "nombreFicheroCabecera.h"
	    Ahora en el código principal podemos llamar al método externo, ejemplo: double area = circleArea(3.0);

	4º) Compilar ambos ficheros.c: gcc -c 1-1circle.c 1-1program.c

	5º) Enlazar el programa principal indicando el fichero objeto que contiene la funcion circleArea (fichero objeto 1-1circle.o): gcc 1-1circle.o 1-1program.o -o 1-1program





-- Enlazado CON LA LIBRERÍA MATH (ponemos en el programa.c el include: #include <math.h>): gcc nombreFicheroObjeto.o -lm -o nombreEjecutable

-- Enlazado CUANDO SE HACE USO DE HILOS(en la cabecera del programa que hace uso de los hilos se pone: #include <pthread.h>): gcc nombreFicheroObjeto.o -lpthread -o nombreEjecutable


-- En el programa.c, si la cabecera no es hecha por nosotros el include es de la forma: #include <cabecera.h>
-- En el programa.c, si la cabecera sí es hecha por nosotros el include es de la forma: #include "1-1circle.h"


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- LIDIAR CON PUNTEROS (GUARDAN UNA DIRECCION DE MEMORIA, O LO QUE ES LO MISMO, QUE APUNTA A UN DATO EN MEMORIA) --

	- Declaracion: tipoDeDato * nombrePuntero; // un puntero así definido no puede ser directamente usado ya que apunta a una zona de memoria desconocida.
	// En lugar de ello, hay que hacer que el puntero apunte a una zona de memoria válida para poder leer y escribir en las posiciones de memoria a las que apunta. 
	// Esto puede hacerse de dos formas: 
		// Haciendo que el puntero apunte a la zona de memoria de una variable del programa (utilizando el operador & para obtener la dirección de una variable)
		// o haciendo que el puntero apunte a una zona de memoria reservada de forma dinámica, habitualmente en el montículo o heap.

	- Para que apunte a una dirección de memoria:
		-- Zona de memoria de una variable del programa: nombrePuntero = &nombreVariable;
		-- Zona de memoria reservada de forma dinámica (se hace con el malloc): nombrePuntero = (char *)malloc(20 * sizeof(char)); // SI SE HACE USO DE ESTA FORMA SE AÑADE EL SIGUIENTE INCLUDE PARA EL MALLOC: #include <stdlib.h> 
			// Luego hay que liberar esa memoria reservada que es apuntada por el puntero con: free(nombrePuntero);

	- Volcar la información a la que apunta un puntero: *nombrePuntero

	- Modificar el contenido de la dirección apuntada por el puntero: *nombrePuntero = nuevoValor



-- Obtener el valor que apunta un puntero con *(*puntero). Esto nos permite modificar ese valor de la siguiente forma: *puntero = nuevoValor

-- Declarar e inicializar un puntero de tipo int a null: int *nombrePuntero = NULL;
-- Volcar la información que contiene un puntero (se hace con el *): *p


-- Ver el número de procesadores que se están usando en la máquina virtual: nproc --all


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


SEGUIR ESTE ORDEN PARA EL CONTROL DE VERSIONES:
	
	1º) git pull (para traer del repositorio a la maquina virtual local los cambios que se han realizado con anterioridad)
		
	2º) git add FICHERO (para añadir al repositorio los ficheros de los que queremos hacer el control de versiones, FICHERO es el nombre del fichero añadido o modificado)

	3º) git commit (para confirmar los cambios que se han realizado en el control de versiones) (confirmamos los git add con ello)

	4º) git push (para enviar los cambios realizados al repositorio); LA PRIMERA VEZ QUE SE VA A LLAMAR A UN GIT PUSH EN UN REPOSITORIO/MV NUEVA SE HACE CON LA INSTRUCCIÓN: git push --set-upstream origin master

-- Comprobar el historial de cambios en el repositorio: git log


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- LIDIAR EL PROFILING CON GPROF (PARA SABER CUANTO TIEMPO LE LLEVA A CADA PARTE DEL CODIGO DE UN PROGRAMA AL EJECUTARSE) --

	1º) Recompilar el programa a analizar con -pg, opción que le indica al compilador que incluya el código del profiler.

	2º) Ejecutar el programa, esto generará el perfil (es un archivo binario de nombre: gmon.out). Si ya existiese un archivo con ese nombre, será sobreescrito.

	3º) Usar el programa gprof para mostrar de manera textual la información de gmon.out.


Proceso en detalle:

	1º) Recompila el programa añadiendo el profiler con esta orden:
		
		gcc prog1.c -pg -o prog1

	2º) Ejecuta el programa con esta orden:

		time ./prog1

	3º) Muestra los ficheros del directorio para comprobar que se ha generado el fichero gmon.out:

		ls

	4º) Genera el informe profiling con esta orden:

		gprof ./prog1 > informe.txt // a gprof hay que pasarle el ejecutable con el que se generó el gmon.out; como gprof genera la salida por pantalla, se usa la última parte de la orden (el > informe.txt) para redireccionar
					   // la salida de gprof al fichero informe.txt

	5º) Edita el fichero informe.txt


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- LIDIAR CON LA OPTIMIZACIÓN DEL CODIGO FUENTE POR PARTE DEL COMPILADOR --

-- Hay tres niveles de optimización, desde el más bajo (o1) hasta el más profundo (o3)


-- PROCEDIMIENTO:

	1º) Se compila el programa con el nivel de optimización que queremos usar:
		
		gcc -o1 prog1.c -o prog1

	2º) Ejecutar (con time) y hacer el resto de procedimientos normales, la optimizacion por parte del compilador solo requiere de su activación sólo en la compilación


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- TIPOS DE DATOS --

-- Byte: 1 Byte
-- Media palabra (hword): 2 Bytes
-- Palabra (word): 4 Bytes
-- Doble palabra (dword): 8 Bytes


Código a partir de la dirección 0800h 
Datos en memoria a partir de la dirección 0400h | Los datos se almacenan en memoria en formato little-endian


En general, las instrucciones serán de word (palabra, 4 bytes), asi que se indexan una dirección de memoria que es multiplo de 4

"Esto se debe a que la variable array apunta a un array de palabras dobles. Los accesos a palabras dobles deben estar alineados con 8 y la dirección siguiente a la más alta de intval no lo está."


movn rd, rs1, rs2 // si rs2 != 0 --> rd = rs1
movz rd, rs1, rs2 // si rs2 == 0 --> rd = rs1
slt rd, rs1, rs2 // si rs1 < rs2 --> rd = 1; sino --> rd = 0

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Aceleracion entre dos programas tras una mejora en el rendimiento = (Rmej / Rorig) = (Torig / Tmej); // una analogía: Aceleración = (Rahora / Rantes) = (Tantes / Tahora) = 1 / ( (1 - Fraccion mejora) + (Fraccion mejora / aceleracion mejora) )


DOS INSTRUCCIONES DEPENDIENTES SEGUIDAS: 2 ciclos de detención
DOS INSTRUCCIONES DEPENDIENTES SEPARADAS POR UNA INSTRUCCIÓN INDEPENDIENTE: 1 ciclo de detención
DOS INSTRUCCIONES DEPENDIENTES SEPARADAS POR DOS O MÁS INSTRUCCIONES INDEPENDIENTES: 0 ciclos de detención
DOS INSTRUCCIONES DEPENDIENTES SEPARADAS POR UNA INSTRUCCIÓN INDEPENDIENTE CON, AL MENOS, UN CICLO DE DETENCIÓN EN SU EJECUCIÓN: 0 ciclos de detención


SALTOS CONDICIONALES SIN EVALUACIÓN AGRESIVA DE SALTOS: Introducen 3 ciclos de detención (primer IF que no se detiene está debajo del WB del salto condicional); ciclos desde el ID hasta el MEM del salto condicional
SALTOS CONDICIONALES CON EVALUACIÓN AGRESIVA DE SALTOS: Introducen 1 ciclo de detención (primer IF que no se detiene está debajo del EX del salto condicional); ciclos desde el ID hasta el EX del salto condicional



DETENCIÓN STR: Detención estructural
DETENCIÓN CNT: Detención de control
DETENCIÓN IOR: Detención de terminación en orden (cuando las intrucciones deben acabar en orden, como en el caso de tener que implementar excepciones precisas en las que éstas detenciones sólo pueden producirse cuando se dispone de 		unidades de ejecución multiciclo); SUELEN PRODUCIRSE CON LAS DETENCIONES WAW
DETENCIÓN MEM: Detención de memoria (Los accesos a memoria pueden requerir varios ciclos de reloj. En ese caso, las etapas IF y MEM se detienen hasta que se completa el acceso a memoria)


¡¡¡¡ El renombrado de registros reducen, o incluso eliminan, las detenciones por dependencias de datos WAW (estas las elimina) y WAR (esta las reduce/elimina) !!!!


4 + nº de intrucciones (las que se terminan de ejecutar) + nº de ciclos de detención del programa = nº de ciclos de ejecución de un programa con pipeline sin unidades de ejecución multiciclo


RAW (READ AFTER WRITTE): Lectura después de escritura = Primero se escribe y luego se lee
WAR (WRITTE AFTER READ): Escritura después de lectura = Primero se lee y luego se escribe
WAW (WRITTE AFTER WRITTE): Escritura después de escritura = Primero se escribe y luego se escribe


Si hay una dependencia WAW entre dos instrucciones que una de ellas tiene una ud de ejecución NO segmentada (EXB) y la otra una ud de ejecución normal, SE DETIENE LA ETAPA EX DE LA SEGUNDA INSTRUCCIÓN HASTA LA ETAPA MEM DE LA PRIMERA INSTRUCCIÓN.


Para que el renombrado de registros suponga una reducción en el número de ciclos de ejecución de un programa, es necesaria la terminación fuera de orden.

LA TERMINACIÓN FUERA DE ORDEN NO ELIMINA LAS DETENCIONES WAW.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


#include <time.h>
#include <stdio.h> // para el printf

metodo()
{
	struct timespec tStart, tEnd;
	double dElapsedTimeS;

	if(clock_gettime(CLOCK_REALTIME, &tStart) < 0) // no se ejecuta correctamente
	{
		...
	}

	Task();

	if(clock_gettime(CLOCK_REALTIME, &tEnd) < 0) // no se ejecuta correctamente
	{
		...
	}


	dElapsedTimeS = (tEnd.tv_sec - tStart.tv_sec);
        dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;
        printf("Elapsed time    : %f s.\n", dElapsedTimeS);
}


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Para proteger la memoria del SO de accesos por parte de las tareas, la arquitectura MIPS64 le reserva un rango de direcciones específico. 
Cualquier dirección en el rango: 
	4000 0000 0000 0000h a FFFF FFFF FFFF FFFFh 
es accesible sólo en modo kernel, esto es, solo por el SO. 
Ubicando el SO en ese rango de direcciones está protegido de cualquier acceso por parte de las tareas (si una tarea accede a ese rango de direcciones saltará una excepción).


Las tareas tienen asociado el rango:
	0000 0000 0000 0000h a 3FFF FFFF FFFF FFFFh
Si una tarea trata de acceder a una dirección de memoria fuera del rango que se le fue asignada (pongamonos en el ejemplo de que accede a una dirección de memoria asignada a otra tarea que no tiene porqué ser una de SO) saltará una excepción si trata de modificar el contenido de dicha dirección de memoria 


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Una tarea repartida entre varios hilos sigue siendo una tarea (no aumenta la productividad sino el tiempo de respuesta)

Una tarea ejecutada por hilo sí son varias tareas ejecutadas a la vez (aumente la productividad en un factor nº de hilos que se ejecutan simultaneamente)


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Especificadores de formato. Se utilizan para mostrar el valor de variables. Comienzan por el carácter %:

%c: carácter (tipo char).

%d: entero decimal con signo (tipo int).

%f: real (tipo float o double).

%s: cadena de caracteres (tipo char *).

%x: entero en formato hexadecimal.

%p: puntero.


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Registro arquitectónico: rx
Registro físico: rrx


